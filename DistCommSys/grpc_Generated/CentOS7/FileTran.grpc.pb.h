// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: FileTran.proto
#ifndef GRPC_FileTran_2eproto__INCLUDED
#define GRPC_FileTran_2eproto__INCLUDED

#include "FileTran.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace InforGuard_ {

class FileTran final {
 public:
  static constexpr char const* service_full_name() {
    return "InforGuard_.FileTran";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::InforGuard_::CheckRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>> AsyncCheck(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::InforGuard_::GetFileBlockRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>> AsyncGetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>>(AsyncGetFileBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>> PrepareAsyncGetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>>(PrepareAsyncGetFileBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::InforGuard_::PutFileBlockRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>> AsyncPutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>>(AsyncPutFileBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>> PrepareAsyncPutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>>(PrepareAsyncPutFileBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::InforGuard_::MakeDirectoryRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>> AsyncMakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>>(AsyncMakeDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>> PrepareAsyncMakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>>(PrepareAsyncMakeDirectoryRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::InforGuard_::MoveFileInRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>> AsyncMoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>>(AsyncMoveFileInRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>> PrepareAsyncMoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>>(PrepareAsyncMoveFileInRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::InforGuard_::MoveFileOutRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>> AsyncMoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>>(AsyncMoveFileOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>> PrepareAsyncMoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>>(PrepareAsyncMoveFileOutRaw(context, request, cq));
    }
    virtual ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::InforGuard_::RenameFileRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>> AsyncRenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    virtual ::grpc::Status QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::InforGuard_::QueryBasePathRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>> AsyncQueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>>(AsyncQueryBasePathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>> PrepareAsyncQueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>>(PrepareAsyncQueryBasePathRaw(context, request, cq));
    }
    virtual ::grpc::Status isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::InforGuard_::isFileExistRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>> AsyncisFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>>(AsyncisFileExistRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>> PrepareAsyncisFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>>(PrepareAsyncisFileExistRaw(context, request, cq));
    }
    virtual ::grpc::Status setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::InforGuard_::setFileTimeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>> AsyncsetFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>>(AsyncsetFileTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>> PrepareAsyncsetFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>>(PrepareAsyncsetFileTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::InforGuard_::getFileTimeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>> AsyncgetFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>>(AsyncgetFileTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>> PrepareAsyncgetFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>>(PrepareAsyncgetFileTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::InforGuard_::sendFileListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>> AsyncsendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>>(AsyncsendFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>> PrepareAsyncsendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>>(PrepareAsyncsendFileListRaw(context, request, cq));
    }
    virtual ::grpc::Status sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::InforGuard_::sendAccessRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>> AsyncsendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>>(AsyncsendAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>> PrepareAsyncsendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>>(PrepareAsyncsendAccessRaw(context, request, cq));
    }
    virtual ::grpc::Status checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::InforGuard_::checkFileListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>> AsynccheckFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>>(AsynccheckFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>> PrepareAsynccheckFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>>(PrepareAsynccheckFileListRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>* AsyncCheckRaw(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::CheckRes>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>* AsyncGetFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::GetFileBlockRes>* PrepareAsyncGetFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>* AsyncPutFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::PutFileBlockRes>* PrepareAsyncPutFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>* AsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MakeDirectoryRes>* PrepareAsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>* AsyncMoveFileInRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileInRes>* PrepareAsyncMoveFileInRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>* AsyncMoveFileOutRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::MoveFileOutRes>* PrepareAsyncMoveFileOutRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::RenameFileRes>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>* AsyncQueryBasePathRaw(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::QueryBasePathRes>* PrepareAsyncQueryBasePathRaw(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>* AsyncisFileExistRaw(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::isFileExistRes>* PrepareAsyncisFileExistRaw(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>* AsyncsetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::setFileTimeRes>* PrepareAsyncsetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>* AsyncgetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::getFileTimeRes>* PrepareAsyncgetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>* AsyncsendFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendFileListRes>* PrepareAsyncsendFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>* AsyncsendAccessRaw(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::sendAccessRes>* PrepareAsyncsendAccessRaw(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>* AsynccheckFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::InforGuard_::checkFileListRes>* PrepareAsynccheckFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::InforGuard_::CheckRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>> AsyncCheck(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    ::grpc::Status GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::InforGuard_::GetFileBlockRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>> AsyncGetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>>(AsyncGetFileBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>> PrepareAsyncGetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>>(PrepareAsyncGetFileBlockRaw(context, request, cq));
    }
    ::grpc::Status PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::InforGuard_::PutFileBlockRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>> AsyncPutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>>(AsyncPutFileBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>> PrepareAsyncPutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>>(PrepareAsyncPutFileBlockRaw(context, request, cq));
    }
    ::grpc::Status MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::InforGuard_::MakeDirectoryRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>> AsyncMakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>>(AsyncMakeDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>> PrepareAsyncMakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>>(PrepareAsyncMakeDirectoryRaw(context, request, cq));
    }
    ::grpc::Status MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::InforGuard_::MoveFileInRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>> AsyncMoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>>(AsyncMoveFileInRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>> PrepareAsyncMoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>>(PrepareAsyncMoveFileInRaw(context, request, cq));
    }
    ::grpc::Status MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::InforGuard_::MoveFileOutRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>> AsyncMoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>>(AsyncMoveFileOutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>> PrepareAsyncMoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>>(PrepareAsyncMoveFileOutRaw(context, request, cq));
    }
    ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::InforGuard_::RenameFileRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>> AsyncRenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    ::grpc::Status QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::InforGuard_::QueryBasePathRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>> AsyncQueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>>(AsyncQueryBasePathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>> PrepareAsyncQueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>>(PrepareAsyncQueryBasePathRaw(context, request, cq));
    }
    ::grpc::Status isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::InforGuard_::isFileExistRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>> AsyncisFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>>(AsyncisFileExistRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>> PrepareAsyncisFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>>(PrepareAsyncisFileExistRaw(context, request, cq));
    }
    ::grpc::Status setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::InforGuard_::setFileTimeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>> AsyncsetFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>>(AsyncsetFileTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>> PrepareAsyncsetFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>>(PrepareAsyncsetFileTimeRaw(context, request, cq));
    }
    ::grpc::Status getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::InforGuard_::getFileTimeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>> AsyncgetFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>>(AsyncgetFileTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>> PrepareAsyncgetFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>>(PrepareAsyncgetFileTimeRaw(context, request, cq));
    }
    ::grpc::Status sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::InforGuard_::sendFileListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>> AsyncsendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>>(AsyncsendFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>> PrepareAsyncsendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>>(PrepareAsyncsendFileListRaw(context, request, cq));
    }
    ::grpc::Status sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::InforGuard_::sendAccessRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>> AsyncsendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>>(AsyncsendAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>> PrepareAsyncsendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>>(PrepareAsyncsendAccessRaw(context, request, cq));
    }
    ::grpc::Status checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::InforGuard_::checkFileListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>> AsynccheckFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>>(AsynccheckFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>> PrepareAsynccheckFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>>(PrepareAsynccheckFileListRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, std::function<void(::grpc::Status)>) override;
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::CheckRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, std::function<void(::grpc::Status)>) override;
      void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFileBlock(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::GetFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, std::function<void(::grpc::Status)>) override;
      void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PutFileBlock(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PutFileBlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::PutFileBlockRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, std::function<void(::grpc::Status)>) override;
      void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MakeDirectory(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MakeDirectory(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MakeDirectoryRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, std::function<void(::grpc::Status)>) override;
      void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MoveFileIn(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MoveFileIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileInRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, std::function<void(::grpc::Status)>) override;
      void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MoveFileOut(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MoveFileOut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::MoveFileOutRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, std::function<void(::grpc::Status)>) override;
      void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RenameFile(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RenameFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::RenameFileRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, std::function<void(::grpc::Status)>) override;
      void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void QueryBasePath(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void QueryBasePath(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::QueryBasePathRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, std::function<void(::grpc::Status)>) override;
      void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void isFileExist(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void isFileExist(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::isFileExistRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, std::function<void(::grpc::Status)>) override;
      void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setFileTime(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::setFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, std::function<void(::grpc::Status)>) override;
      void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getFileTime(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getFileTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::getFileTimeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, std::function<void(::grpc::Status)>) override;
      void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendFileList(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, std::function<void(::grpc::Status)>) override;
      void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendAccess(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendAccess(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::sendAccessRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, std::function<void(::grpc::Status)>) override;
      void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void checkFileList(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void checkFileList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::InforGuard_::checkFileListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>* AsyncCheckRaw(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::CheckRes>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::InforGuard_::CheckReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>* AsyncGetFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::GetFileBlockRes>* PrepareAsyncGetFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::GetFileBlockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>* AsyncPutFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::PutFileBlockRes>* PrepareAsyncPutFileBlockRaw(::grpc::ClientContext* context, const ::InforGuard_::PutFileBlockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>* AsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MakeDirectoryRes>* PrepareAsyncMakeDirectoryRaw(::grpc::ClientContext* context, const ::InforGuard_::MakeDirectoryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>* AsyncMoveFileInRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileInRes>* PrepareAsyncMoveFileInRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileInReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>* AsyncMoveFileOutRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::MoveFileOutRes>* PrepareAsyncMoveFileOutRaw(::grpc::ClientContext* context, const ::InforGuard_::MoveFileOutReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::RenameFileRes>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::InforGuard_::RenameFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>* AsyncQueryBasePathRaw(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::QueryBasePathRes>* PrepareAsyncQueryBasePathRaw(::grpc::ClientContext* context, const ::InforGuard_::QueryBasePathReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>* AsyncisFileExistRaw(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::isFileExistRes>* PrepareAsyncisFileExistRaw(::grpc::ClientContext* context, const ::InforGuard_::isFileExistReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>* AsyncsetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::setFileTimeRes>* PrepareAsyncsetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::setFileTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>* AsyncgetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::getFileTimeRes>* PrepareAsyncgetFileTimeRaw(::grpc::ClientContext* context, const ::InforGuard_::getFileTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>* AsyncsendFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendFileListRes>* PrepareAsyncsendFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::sendFileListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>* AsyncsendAccessRaw(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::sendAccessRes>* PrepareAsyncsendAccessRaw(::grpc::ClientContext* context, const ::InforGuard_::sendAccessReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>* AsynccheckFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::InforGuard_::checkFileListRes>* PrepareAsynccheckFileListRaw(::grpc::ClientContext* context, const ::InforGuard_::checkFileListReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Check_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFileBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_PutFileBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_MakeDirectory_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveFileIn_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveFileOut_;
    const ::grpc::internal::RpcMethod rpcmethod_RenameFile_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryBasePath_;
    const ::grpc::internal::RpcMethod rpcmethod_isFileExist_;
    const ::grpc::internal::RpcMethod rpcmethod_setFileTime_;
    const ::grpc::internal::RpcMethod rpcmethod_getFileTime_;
    const ::grpc::internal::RpcMethod rpcmethod_sendFileList_;
    const ::grpc::internal::RpcMethod rpcmethod_sendAccess_;
    const ::grpc::internal::RpcMethod rpcmethod_checkFileList_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Check(::grpc::ServerContext* context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response);
    virtual ::grpc::Status GetFileBlock(::grpc::ServerContext* context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response);
    virtual ::grpc::Status PutFileBlock(::grpc::ServerContext* context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response);
    virtual ::grpc::Status MakeDirectory(::grpc::ServerContext* context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response);
    virtual ::grpc::Status MoveFileIn(::grpc::ServerContext* context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response);
    virtual ::grpc::Status MoveFileOut(::grpc::ServerContext* context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response);
    virtual ::grpc::Status RenameFile(::grpc::ServerContext* context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response);
    virtual ::grpc::Status QueryBasePath(::grpc::ServerContext* context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response);
    virtual ::grpc::Status isFileExist(::grpc::ServerContext* context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response);
    virtual ::grpc::Status setFileTime(::grpc::ServerContext* context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response);
    virtual ::grpc::Status getFileTime(::grpc::ServerContext* context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response);
    virtual ::grpc::Status sendFileList(::grpc::ServerContext* context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response);
    virtual ::grpc::Status sendAccess(::grpc::ServerContext* context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response);
    virtual ::grpc::Status checkFileList(::grpc::ServerContext* context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Check() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::InforGuard_::CheckReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::CheckRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFileBlock() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileBlock(::grpc::ServerContext* context, ::InforGuard_::GetFileBlockReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::GetFileBlockRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutFileBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFileBlock(::grpc::ServerContext* context, ::InforGuard_::PutFileBlockReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::PutFileBlockRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMakeDirectory(::grpc::ServerContext* context, ::InforGuard_::MakeDirectoryReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::MakeDirectoryRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveFileIn() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFileIn(::grpc::ServerContext* context, ::InforGuard_::MoveFileInReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::MoveFileInRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveFileOut() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFileOut(::grpc::ServerContext* context, ::InforGuard_::MoveFileOutReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::MoveFileOutRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RenameFile() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::InforGuard_::RenameFileReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::RenameFileRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryBasePath() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryBasePath(::grpc::ServerContext* context, ::InforGuard_::QueryBasePathReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::QueryBasePathRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isFileExist() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisFileExist(::grpc::ServerContext* context, ::InforGuard_::isFileExistReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::isFileExistRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setFileTime() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFileTime(::grpc::ServerContext* context, ::InforGuard_::setFileTimeReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::setFileTimeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getFileTime() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetFileTime(::grpc::ServerContext* context, ::InforGuard_::getFileTimeReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::getFileTimeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendFileList() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendFileList(::grpc::ServerContext* context, ::InforGuard_::sendFileListReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::sendFileListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendAccess() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendAccess(::grpc::ServerContext* context, ::InforGuard_::sendAccessReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::sendAccessRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_checkFileList() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcheckFileList(::grpc::ServerContext* context, ::InforGuard_::checkFileListReq* request, ::grpc::ServerAsyncResponseWriter< ::InforGuard_::checkFileListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Check<WithAsyncMethod_GetFileBlock<WithAsyncMethod_PutFileBlock<WithAsyncMethod_MakeDirectory<WithAsyncMethod_MoveFileIn<WithAsyncMethod_MoveFileOut<WithAsyncMethod_RenameFile<WithAsyncMethod_QueryBasePath<WithAsyncMethod_isFileExist<WithAsyncMethod_setFileTime<WithAsyncMethod_getFileTime<WithAsyncMethod_sendFileList<WithAsyncMethod_sendAccess<WithAsyncMethod_checkFileList<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::CheckReq, ::InforGuard_::CheckRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::CheckReq* request, ::InforGuard_::CheckRes* response) { return this->Check(context, request, response); }));}
    void SetMessageAllocatorFor_Check(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::CheckReq, ::InforGuard_::CheckRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::CheckReq, ::InforGuard_::CheckRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetFileBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::GetFileBlockReq, ::InforGuard_::GetFileBlockRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::GetFileBlockReq* request, ::InforGuard_::GetFileBlockRes* response) { return this->GetFileBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetFileBlock(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::GetFileBlockReq, ::InforGuard_::GetFileBlockRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::GetFileBlockReq, ::InforGuard_::GetFileBlockRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFileBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFileBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PutFileBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::PutFileBlockReq, ::InforGuard_::PutFileBlockRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::PutFileBlockReq* request, ::InforGuard_::PutFileBlockRes* response) { return this->PutFileBlock(context, request, response); }));}
    void SetMessageAllocatorFor_PutFileBlock(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::PutFileBlockReq, ::InforGuard_::PutFileBlockRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::PutFileBlockReq, ::InforGuard_::PutFileBlockRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PutFileBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PutFileBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MakeDirectory() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MakeDirectoryReq, ::InforGuard_::MakeDirectoryRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::MakeDirectoryReq* request, ::InforGuard_::MakeDirectoryRes* response) { return this->MakeDirectory(context, request, response); }));}
    void SetMessageAllocatorFor_MakeDirectory(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::MakeDirectoryReq, ::InforGuard_::MakeDirectoryRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MakeDirectoryReq, ::InforGuard_::MakeDirectoryRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MakeDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MakeDirectory(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveFileIn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MoveFileInReq, ::InforGuard_::MoveFileInRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::MoveFileInReq* request, ::InforGuard_::MoveFileInRes* response) { return this->MoveFileIn(context, request, response); }));}
    void SetMessageAllocatorFor_MoveFileIn(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::MoveFileInReq, ::InforGuard_::MoveFileInRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MoveFileInReq, ::InforGuard_::MoveFileInRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MoveFileIn(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MoveFileIn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MoveFileOut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MoveFileOutReq, ::InforGuard_::MoveFileOutRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::MoveFileOutReq* request, ::InforGuard_::MoveFileOutRes* response) { return this->MoveFileOut(context, request, response); }));}
    void SetMessageAllocatorFor_MoveFileOut(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::MoveFileOutReq, ::InforGuard_::MoveFileOutRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::MoveFileOutReq, ::InforGuard_::MoveFileOutRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MoveFileOut(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MoveFileOut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RenameFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::RenameFileReq, ::InforGuard_::RenameFileRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::RenameFileReq* request, ::InforGuard_::RenameFileRes* response) { return this->RenameFile(context, request, response); }));}
    void SetMessageAllocatorFor_RenameFile(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::RenameFileReq, ::InforGuard_::RenameFileRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::RenameFileReq, ::InforGuard_::RenameFileRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RenameFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_QueryBasePath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::QueryBasePathReq, ::InforGuard_::QueryBasePathRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::QueryBasePathReq* request, ::InforGuard_::QueryBasePathRes* response) { return this->QueryBasePath(context, request, response); }));}
    void SetMessageAllocatorFor_QueryBasePath(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::QueryBasePathReq, ::InforGuard_::QueryBasePathRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::QueryBasePathReq, ::InforGuard_::QueryBasePathRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* QueryBasePath(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* QueryBasePath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_isFileExist() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::isFileExistReq, ::InforGuard_::isFileExistRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::isFileExistReq* request, ::InforGuard_::isFileExistRes* response) { return this->isFileExist(context, request, response); }));}
    void SetMessageAllocatorFor_isFileExist(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::isFileExistReq, ::InforGuard_::isFileExistRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::isFileExistReq, ::InforGuard_::isFileExistRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isFileExist(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isFileExist(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setFileTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::setFileTimeReq, ::InforGuard_::setFileTimeRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::setFileTimeReq* request, ::InforGuard_::setFileTimeRes* response) { return this->setFileTime(context, request, response); }));}
    void SetMessageAllocatorFor_setFileTime(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::setFileTimeReq, ::InforGuard_::setFileTimeRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::setFileTimeReq, ::InforGuard_::setFileTimeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setFileTime(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setFileTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getFileTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::getFileTimeReq, ::InforGuard_::getFileTimeRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::getFileTimeReq* request, ::InforGuard_::getFileTimeRes* response) { return this->getFileTime(context, request, response); }));}
    void SetMessageAllocatorFor_getFileTime(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::getFileTimeReq, ::InforGuard_::getFileTimeRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::getFileTimeReq, ::InforGuard_::getFileTimeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getFileTime(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getFileTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendFileList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::sendFileListReq, ::InforGuard_::sendFileListRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::sendFileListReq* request, ::InforGuard_::sendFileListRes* response) { return this->sendFileList(context, request, response); }));}
    void SetMessageAllocatorFor_sendFileList(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::sendFileListReq, ::InforGuard_::sendFileListRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::sendFileListReq, ::InforGuard_::sendFileListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendFileList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::sendAccessReq, ::InforGuard_::sendAccessRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::sendAccessReq* request, ::InforGuard_::sendAccessRes* response) { return this->sendAccess(context, request, response); }));}
    void SetMessageAllocatorFor_sendAccess(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::sendAccessReq, ::InforGuard_::sendAccessRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::sendAccessReq, ::InforGuard_::sendAccessRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_checkFileList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::checkFileListReq, ::InforGuard_::checkFileListRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::InforGuard_::checkFileListReq* request, ::InforGuard_::checkFileListRes* response) { return this->checkFileList(context, request, response); }));}
    void SetMessageAllocatorFor_checkFileList(
        ::grpc::experimental::MessageAllocator< ::InforGuard_::checkFileListReq, ::InforGuard_::checkFileListRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::InforGuard_::checkFileListReq, ::InforGuard_::checkFileListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* checkFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* checkFileList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Check<ExperimentalWithCallbackMethod_GetFileBlock<ExperimentalWithCallbackMethod_PutFileBlock<ExperimentalWithCallbackMethod_MakeDirectory<ExperimentalWithCallbackMethod_MoveFileIn<ExperimentalWithCallbackMethod_MoveFileOut<ExperimentalWithCallbackMethod_RenameFile<ExperimentalWithCallbackMethod_QueryBasePath<ExperimentalWithCallbackMethod_isFileExist<ExperimentalWithCallbackMethod_setFileTime<ExperimentalWithCallbackMethod_getFileTime<ExperimentalWithCallbackMethod_sendFileList<ExperimentalWithCallbackMethod_sendAccess<ExperimentalWithCallbackMethod_checkFileList<Service > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Check<ExperimentalWithCallbackMethod_GetFileBlock<ExperimentalWithCallbackMethod_PutFileBlock<ExperimentalWithCallbackMethod_MakeDirectory<ExperimentalWithCallbackMethod_MoveFileIn<ExperimentalWithCallbackMethod_MoveFileOut<ExperimentalWithCallbackMethod_RenameFile<ExperimentalWithCallbackMethod_QueryBasePath<ExperimentalWithCallbackMethod_isFileExist<ExperimentalWithCallbackMethod_setFileTime<ExperimentalWithCallbackMethod_getFileTime<ExperimentalWithCallbackMethod_sendFileList<ExperimentalWithCallbackMethod_sendAccess<ExperimentalWithCallbackMethod_checkFileList<Service > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Check() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFileBlock() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutFileBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveFileIn() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveFileOut() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RenameFile() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryBasePath() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isFileExist() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setFileTime() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getFileTime() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendFileList() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendAccess() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_checkFileList() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Check() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFileBlock() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutFileBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFileBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMakeDirectory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveFileIn() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFileIn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveFileOut() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFileOut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RenameFile() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryBasePath() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryBasePath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isFileExist() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisFileExist(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setFileTime() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFileTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getFileTime() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetFileTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendFileList() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendFileList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendAccess() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendAccess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_checkFileList() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcheckFileList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Check(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetFileBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFileBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetFileBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetFileBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PutFileBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutFileBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PutFileBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PutFileBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MakeDirectory() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MakeDirectory(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MakeDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MakeDirectory(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveFileIn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveFileIn(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MoveFileIn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MoveFileIn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveFileOut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveFileOut(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MoveFileOut(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MoveFileOut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RenameFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RenameFile(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RenameFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_QueryBasePath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryBasePath(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* QueryBasePath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* QueryBasePath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_isFileExist() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isFileExist(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isFileExist(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isFileExist(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setFileTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setFileTime(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setFileTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setFileTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getFileTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getFileTime(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getFileTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getFileTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendFileList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendFileList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendFileList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendAccess() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendAccess(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendAccess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendAccess(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_checkFileList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->checkFileList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* checkFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* checkFileList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Check() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::CheckReq, ::InforGuard_::CheckRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::CheckReq, ::InforGuard_::CheckRes>* streamer) {
                       return this->StreamedCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::InforGuard_::CheckReq* /*request*/, ::InforGuard_::CheckRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::CheckReq,::InforGuard_::CheckRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFileBlock() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::GetFileBlockReq, ::InforGuard_::GetFileBlockRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::GetFileBlockReq, ::InforGuard_::GetFileBlockRes>* streamer) {
                       return this->StreamedGetFileBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::GetFileBlockReq* /*request*/, ::InforGuard_::GetFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFileBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::GetFileBlockReq,::InforGuard_::GetFileBlockRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutFileBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutFileBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::PutFileBlockReq, ::InforGuard_::PutFileBlockRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::PutFileBlockReq, ::InforGuard_::PutFileBlockRes>* streamer) {
                       return this->StreamedPutFileBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PutFileBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutFileBlock(::grpc::ServerContext* /*context*/, const ::InforGuard_::PutFileBlockReq* /*request*/, ::InforGuard_::PutFileBlockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutFileBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::PutFileBlockReq,::InforGuard_::PutFileBlockRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MakeDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MakeDirectory() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::MakeDirectoryReq, ::InforGuard_::MakeDirectoryRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::MakeDirectoryReq, ::InforGuard_::MakeDirectoryRes>* streamer) {
                       return this->StreamedMakeDirectory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MakeDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MakeDirectory(::grpc::ServerContext* /*context*/, const ::InforGuard_::MakeDirectoryReq* /*request*/, ::InforGuard_::MakeDirectoryRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMakeDirectory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::MakeDirectoryReq,::InforGuard_::MakeDirectoryRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveFileIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveFileIn() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::MoveFileInReq, ::InforGuard_::MoveFileInRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::MoveFileInReq, ::InforGuard_::MoveFileInRes>* streamer) {
                       return this->StreamedMoveFileIn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveFileIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveFileIn(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileInReq* /*request*/, ::InforGuard_::MoveFileInRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveFileIn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::MoveFileInReq,::InforGuard_::MoveFileInRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveFileOut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveFileOut() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::MoveFileOutReq, ::InforGuard_::MoveFileOutRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::MoveFileOutReq, ::InforGuard_::MoveFileOutRes>* streamer) {
                       return this->StreamedMoveFileOut(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveFileOut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveFileOut(::grpc::ServerContext* /*context*/, const ::InforGuard_::MoveFileOutReq* /*request*/, ::InforGuard_::MoveFileOutRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveFileOut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::MoveFileOutReq,::InforGuard_::MoveFileOutRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RenameFile() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::RenameFileReq, ::InforGuard_::RenameFileRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::RenameFileReq, ::InforGuard_::RenameFileRes>* streamer) {
                       return this->StreamedRenameFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::InforGuard_::RenameFileReq* /*request*/, ::InforGuard_::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRenameFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::RenameFileReq,::InforGuard_::RenameFileRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryBasePath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryBasePath() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::QueryBasePathReq, ::InforGuard_::QueryBasePathRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::QueryBasePathReq, ::InforGuard_::QueryBasePathRes>* streamer) {
                       return this->StreamedQueryBasePath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryBasePath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryBasePath(::grpc::ServerContext* /*context*/, const ::InforGuard_::QueryBasePathReq* /*request*/, ::InforGuard_::QueryBasePathRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryBasePath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::QueryBasePathReq,::InforGuard_::QueryBasePathRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isFileExist : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isFileExist() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::isFileExistReq, ::InforGuard_::isFileExistRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::isFileExistReq, ::InforGuard_::isFileExistRes>* streamer) {
                       return this->StreamedisFileExist(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isFileExist() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isFileExist(::grpc::ServerContext* /*context*/, const ::InforGuard_::isFileExistReq* /*request*/, ::InforGuard_::isFileExistRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisFileExist(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::isFileExistReq,::InforGuard_::isFileExistRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setFileTime() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::setFileTimeReq, ::InforGuard_::setFileTimeRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::setFileTimeReq, ::InforGuard_::setFileTimeRes>* streamer) {
                       return this->StreamedsetFileTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::setFileTimeReq* /*request*/, ::InforGuard_::setFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetFileTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::setFileTimeReq,::InforGuard_::setFileTimeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getFileTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getFileTime() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::getFileTimeReq, ::InforGuard_::getFileTimeRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::getFileTimeReq, ::InforGuard_::getFileTimeRes>* streamer) {
                       return this->StreamedgetFileTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getFileTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getFileTime(::grpc::ServerContext* /*context*/, const ::InforGuard_::getFileTimeReq* /*request*/, ::InforGuard_::getFileTimeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetFileTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::getFileTimeReq,::InforGuard_::getFileTimeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendFileList() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::sendFileListReq, ::InforGuard_::sendFileListRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::sendFileListReq, ::InforGuard_::sendFileListRes>* streamer) {
                       return this->StreamedsendFileList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendFileListReq* /*request*/, ::InforGuard_::sendFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendFileList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::sendFileListReq,::InforGuard_::sendFileListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendAccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendAccess() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::sendAccessReq, ::InforGuard_::sendAccessRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::sendAccessReq, ::InforGuard_::sendAccessRes>* streamer) {
                       return this->StreamedsendAccess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendAccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendAccess(::grpc::ServerContext* /*context*/, const ::InforGuard_::sendAccessReq* /*request*/, ::InforGuard_::sendAccessRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendAccess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::sendAccessReq,::InforGuard_::sendAccessRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_checkFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_checkFileList() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InforGuard_::checkFileListReq, ::InforGuard_::checkFileListRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::InforGuard_::checkFileListReq, ::InforGuard_::checkFileListRes>* streamer) {
                       return this->StreamedcheckFileList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_checkFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status checkFileList(::grpc::ServerContext* /*context*/, const ::InforGuard_::checkFileListReq* /*request*/, ::InforGuard_::checkFileListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcheckFileList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InforGuard_::checkFileListReq,::InforGuard_::checkFileListRes>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_GetFileBlock<WithStreamedUnaryMethod_PutFileBlock<WithStreamedUnaryMethod_MakeDirectory<WithStreamedUnaryMethod_MoveFileIn<WithStreamedUnaryMethod_MoveFileOut<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_QueryBasePath<WithStreamedUnaryMethod_isFileExist<WithStreamedUnaryMethod_setFileTime<WithStreamedUnaryMethod_getFileTime<WithStreamedUnaryMethod_sendFileList<WithStreamedUnaryMethod_sendAccess<WithStreamedUnaryMethod_checkFileList<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_GetFileBlock<WithStreamedUnaryMethod_PutFileBlock<WithStreamedUnaryMethod_MakeDirectory<WithStreamedUnaryMethod_MoveFileIn<WithStreamedUnaryMethod_MoveFileOut<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_QueryBasePath<WithStreamedUnaryMethod_isFileExist<WithStreamedUnaryMethod_setFileTime<WithStreamedUnaryMethod_getFileTime<WithStreamedUnaryMethod_sendFileList<WithStreamedUnaryMethod_sendAccess<WithStreamedUnaryMethod_checkFileList<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace InforGuard_


#endif  // GRPC_FileTran_2eproto__INCLUDED
